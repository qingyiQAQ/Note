# 第一章 绪论

## 数据结构的基本概念

1、基本概念和术语

数据：描述客观事物属性的所有能输入到计算机中并被计算机识别和处理的符号的集合。

数据元素：数据的基本单位。由**数据项**组成。例如：学生由学号，姓名，性别组成。

数据对象：具有相同性质的数据元素的集合。是数据的一个子集。

数据类型：一个值的集合和定义在此集合上的一组操作的总称。
		1)原子类型：值不可再分的数据类型
		2)结构类型：值可以再分解的数据类型
		3)抽象数据类型(ADT)：抽象数据组织及与之相关的操作

数据结构：数据元素相互之间的一种或多种特定关系，包括：逻辑结构，存储结构，数据的运算。

![image-20240116120406326](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240116120406326.png)

2、数据结构三要素

逻辑结构：数据元素之间的逻辑关系，分为：集合，线性结构，树形结构，图状(网状)结构

存储结构：数据结构在计算机中的表示，又称**物理结构**，分为：
		顺序存储：连续存储
		链式存储：通过指针指向下一个元素
		索引存储：附加一个索引表检索
		散列存储：哈希存储，根据关键字计算存储地址

数据的运算：包括运算的定义和实现

## 算法和算法评价

1、算法的基本概念

概念：算法是对特定问题的求解步骤的一种描述，是指令的有限序列。

5个特性：有穷性，确定性，可行性，输入(0或多个)，输出(1或多个)

好的算法目标：正确性，可读性，健壮性，高效率和低存储量

2、算法效率的度量

时间复杂度：所有语句的频度（重复执行的次数）之和

T(n)=O(f(n))

一般考虑最坏的时间复杂度

空间复杂度：算法所耗费的空间

S(n)=O(g(n))

原地工作O(1)

# 第二章 线性表

## 线性表定义和基本操作

1、线性表定义：具有相同数据类型的n个数据元素的有限序列

2、线性表特点：
		元素个数有限
		元素逻辑上有序
		每个元素都是独立元素
		数据类型相同
		元素具有抽象性

3、基本操作

InitList(&L)初始化表
Length(L)求表长
LocateElem(L,e)按值查找
GetElem(L,i)按位查找
ListInsert(&L,i,e)在第i个位置插入元素e
ListDelete(&L,i,&e)删除第i个元素的值，并用&e返回该元素
PrintList(L)输出操作
Empty(L)判断是否为空
DestroyList(&L)销毁并释放内存

## 线性表的顺序表示

1、顺序表的定义：线性表的顺序存储

使用数组存储

可以静态分配也可以动态分配

特点：随机访问O(1)，存储密度高，插入和删除需要移动大量元素

线性表序号从1开始

## 线性表的链式表示

1、单链表

```c
typedef struct LNode{			//定义单链表结点类型
	ElemType data;				//数据域
	struct LNode *next;			//指针域
}LNode,	*LinkList;
```

通常使用**头指针**标识一个单链表

第一个节点之前设置一个**头结点**，可以存储长度信息

使用头结点的两个优点：
(1)第一个节点的处理与其他节点得到统一
(2)空链表与非空链表的处理得到统一

基本操作：创建时可以头插，尾插

2、双链表

```
typedef struct DNode{			//定义双链表结点类型
	ElemType data;				//数据域
	struct DNode *prior,*next;	//前驱和后继指针
}DNode,	*DLinkList;
```

(1)插入

在p后插入s

```c
s->next=p->next;
p->next->prior=s;
s->prior=p;
p->next=s;
```

(2)删除

删除q节点

```c
p->next=q->next;
q->next->prior=p;
free(q);
```

3、循环链表

单链表，最后一个节点指针指向头节点

4、循环双链表

空表，头节点的两个指针都指向自己

5、静态链表

借助数组来描述线性表的链式存储

指针是节点的相对地址，又称**游标**

```
#define MaxSize 50		//静态链表最大长度
typedef struct{			//静态链表结构类型的定义
	ElemType data;		//存储数据元素
	int next;			//下一个元素数组下标
}SLinkList[MaxSize];
```

以next==-1作为结束标志

SLinkList[0]无数据，有指针指向第一个元素

例：

|      | 2    |
| ---- | ---- |
| b    | 6    |
| a    | 1    |
| d    | -1   |
|      |      |
|      |      |
| c    | 1    |

得到abcd

## 顺序表和链表的比较

1、存取（读写）方式

顺序表可以顺序存取，也可以随机存取

链表只能顺序存取

2、逻辑结构和物理结构

顺序表物理相邻

链表不一定相邻

3、查找、插入和删除操作

按值查找：无序顺序表O(n)、有序顺序表O(log2n)

按序查找：顺序表O(1)、链表O(n)

插入和删除：顺序表O(n)、链表O(1)

# 第三章 栈、队列和数组

## 栈的基本概念

1、栈是只允许在一段进行插入或删除操作的线性表

栈顶（Top）：允许进行**插入删除**的那一端。

栈底（Bottom）：固定的，不允许插入删除。

空栈：不含任何元素。

后进先出（Last In First Out，LIFO)

n个不同元素进栈，出栈序列数为Catalan(n) = (2n)! / ((n+1)! * n!)

2、栈的基本操作

InitStack(&S)：初始化一个空栈S
StackEmpty(S)：判断栈是否为空
Push(&S,x)：进栈
Pop(&S,&x)：出栈，用x返回
GetTop(S,&x)：读栈顶元素
DestoryStack(&S)：销毁栈

3、栈的顺序存储结构

```c
#define MaxSize 50				//定义栈中元素最大个数
typedef struct{
	ElemType data[MaxSize];		//存放栈中元素
	int top;					//栈顶指针
}SqStack;
```

初始S.top=-1

进栈：栈不满时，S.top++，再送值到栈顶

出栈：栈不空时，先取栈顶元素，S.top--

栈空条件：S.top==-1

栈满条件：S.top==MaxSize-1

栈长：S.top+1

4、顺序栈基本运算

(1)初始化

```c
void InitStack(SqStack &S){
	S.top==-1;					//初始化栈顶指针
}
```

(2)判栈空

```c
bool StackEmpty(SqStack S){
	if(S.top==-1)return true;	//栈空
	else return false;			//不空
}
```

(3)进栈

```c
bool Push(SqStack &S,ElemType x){
	if(S.top==MaxSize-1)return false;	//栈满，报错
	S.data[++S.top]=x;					//指针+1，再入栈
    return false;
}
```

(4)出栈

```c
bool Pop(SqStack &S,ElemType x){
	if(S.top==-1)return false;			//栈空，报错
	x=S.data[S.top--];					//先出栈，指针再-1
	return true;
}
```

(5)读栈顶元素

```c
bool GetTop(SqStack S,ElemType &x){
	if(S.top==-1)return false;			//栈空，报错
	x=S.data[S.top];					//x记录栈顶元素
	return true;
}
```

5、共享栈

两个栈共享一个移位数组空间，栈底分别设置在两端，向中间延伸

初始时top0=-1，top1=MaxSize

栈满时top1-top0==1

6、栈的链式存储结构

```
typedef struct Linknode{
	ElemType data;			//数据域
	struct Linknode *next;	//指针域
}*LiStack;					//栈类型定义
```

## 队列的基本概念

1、队列只允许在表的一段进行插入，另一端进行删除。

入队：插入

出队/离队：删除

特性：先进先出（First In First Out，FIFO）

队头/队首：允许删除的一段

队尾：允许插入的一段

空队列：不含任何元素

2、队列基本操作

InitQueue(&Q)：初始化队列
QueueEmpty(Q)：判断队列是否为空
EnQueue(&Q,x)：入队
DeQueue(&Q,&x)：出队，用x返回值
GetHead(Q,&x)：读队头元素，用x返回

3、队列的顺序存储

```c
#define MaxSize 50			//定义队列中元素的最大个数
typedef struct{
	ElemType data[MaxSize];	//存放队列元素
	int front,rear;			//队头指针和队尾指针
}SqQueue;
```

初始：Q.front=Q.rear=0

进队：队不满时，送值到队尾，rear++
出队：队不空时，取队头元素，front++

注意：rear指向的元素没有存值，rear-1为队尾元素，front为队头元素

顺序队列会出现“上溢出”，是一种“假溢出”（当Q.rear==MaxSize时不一定存满）

2、循环队列

队首指针进1：Q.front=(Q.front+1)%MaxSize
队尾指针进1：Q.rear=(Q.rear+1)%MaxSize
队列长度：(Q.rear+MaxSize-Q.front)%MaxSize
队空/队满条件：Q.rear==Q.front

如何区别队空队满？

(1)约定队头指针在队尾下一位置为队满，即(Q.rear+1)%MaxSize==Q.front
队空条件：Q.front==Q.rear
这样会牺牲一个存储单元

(2)类型中增设一个表示数据元素个数的字段size，即Q.size==MaxSize时队满

(3)类型中增设一个判断队满的数据成员tag，tag==0&&Q.front==Q,size则队空，tag==1&&Q.front==Q,size则队满

基本操作：

(1)初始化

```c
void InitQueue(SqQueue &Q){
	Q.rear=Q.front=0;			//初始化队首，队尾指针
}
```

(2)判队空

```c
bool isEmpty(Sqstack Q){
	if(Q.rear==Q.front)return true;		//队空条件
	else return false;
}
```

(3)入队

```c
bool EnQueue(SqQueue &Q,ElemType x){
	if((Q.rear+1)%MaxSize==Q.front)return false;		//队满则报错
	Q.data[Q.rear]=x;
	Q.rear=(Q.rear+1)%MaxSize;				//队尾指针+1取模
	return true;
}
```

(4)出队

```c
bool DeQueue(SqQueue &Q,Elemtype &x){
	if(Q.rear==Q.front)return false;					//队空则报错
	x=Q.data[Q.front];
	Q.front=(Q.front+1)%MaxSize;			//队头指针+1再取模
	return true;
}
```

3、队列的链式存储

```c
typedef struct LinkNode{		//链式队列节点
	Elemtype data;
	struct LinkNode *next;
}LinkNode;
typedef struct{					//链式队列
	LinkNode *front,*rear;		//队首指针和队尾指针
}*LinkQueue;
```

​	队空：Q.front==NULL&&Q.rear==NULL

基本操作：

(1)初始化

```c
void InitQueue(LinkQueue &Q){
	Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));		//建立头节点
	Q.front->next=NULL;			//初始为空
}
```

(2)判队空

```c
bool IsEmpty(LinkQUeue Q){
	if(Q.front==Q.rear)return true;
	else return false;
}
```

(3)入队

```c
void EnQueue(LinkQueue &Q,ElemType x){
	LinkNode *s=(LinkNode*)malloc(typeof(LinkNode));
	s->data=x;
	s->next=NULL;		//创建新节点，加入到链尾
	Q.rear->next=s;
	Q.rear=s;
}
```

(4)出队

```c
bool DeQueue(LinkQueue &Q,ElemType &x){
	if(Q.front==Q.rear)return false;		//空队
	LinkNode *p=Q.front->next;
	x=p->data;
	Q.front->next=p->next;
	if(Q.rear==p)Q.rear=Q.front;		//若原队列只有一个节点，删除后变空
	free(p);
	return true;
}
```

4、双段队列

两端都可以进行入队和出队操作的队列

两端分别成为**前段**和**后端**

输出受限的双端队列：前段允许插入删除但是后端只允许插入

输入受限的双端队列：前段允许插入删除但是后端只允许删除

 

## 栈和队列的作用

1、栈的应用：

(1)括号匹配

(2)表达式求值

后缀表达式求值

中缀表达式转化为后缀表达式？

isp（in stack priority）栈内优先数

icp（in coming priority）栈外优先数

| 操作符 | #    | (    | *,/  | +,-  | )    |
| :----: | ---- | ---- | ---- | ---- | ---- |
|  isp   | 0    | 1    | 5    | 3    | 6    |
|  icp   | 0    | 6    | 4    | 2    | 1    |

一开始先进栈一个#

如果是扫描到操作数，则直接输出

如果扫描到操作符，设该操作符为a，栈顶元素为b

​		情况1：如果isp(b)==icp(a)，直接退栈

​		情况2：如果isp(b)>icp(a)，退栈并输出，出现该情况要重新执行比较直到出现情况1或3

​		情况3：如果isp(b)<icp(a)，进栈

(3)递归

2、队列的应用

(1)层次遍历（广度优先搜索）

## 数组和特殊矩阵

1、数组的定义

数组的维界：数组下标的取指范围

数组是线性表的推广

2、数组的存储结构

一维数组连续存储：LOC(ai)=LOC(a0)+i*L(0<=i<=n)

多维数组：设行下标的范围为0-h1，列下标的范围为0-h2

行优先：LOC(ai,j)=LOC(a0,0)+[i*(h2+1)+j]**L

列优先：LOC(ai,j)=LOC(a0,0)+[j*(h1+1)+i]**L

3、特殊矩阵的压缩存储

(1)对称矩阵（ai,j==aj,i）

存放在一位数组B[n*(n+1)/2]中

如何由ai,j获得在一维数组的存储位置k？

k=i*(i-1)/2+j-1，i>=j

k=j+(j-1)/2+i-1，i<j

(2)三角矩阵

与上述类似

(3)三对角矩阵

仅有(ai,i	ai,i+1	ai+1,i)

k=2*i+j-3

(4)稀疏矩阵

非零元素少

通常使用三个一维数组分别存储横纵坐标和数据或者使用十字链表

# 第四章 串

## 串的定义和实现

1、定义：串是由零个或多个字符组成的有限序列

S='a1a2...an'

n==0为空串

串中任意多个**连续**字符组成的子序列称为该串的子串

由空格组成的串是空格串不是空串

2、存储结构

定长顺序存储表示

```c
#define MAXLEN 255		//预定义最大串长为255
typedef struct {
	char ch[MAXLEN];	//每个分量存储一个字符
	int length;			//串的实际长度
}SString;
```

超过长度会被截断

2、堆分配存储表示

仍然连续存储，但是可以动态分配长度

```c
typedef struct{
	char ch*;		//按串长分配存储区，ch指向串的基地址
	int length;		//串的长度
}HString;
```

3、块链存储表示

类似链表存储，每个节点可以存放多个字符

## 串的基本操作

StrAssign(&T,chars)：把串T赋值为chars
StrCopy(&T,S)：把S复制到T中
StrEmpty(S)：判断是否为空
StrCompare(S,T)：S>T返回值>0；S==T返回0；S<T返回值<0
StrLength(S)：求串长
SubString(&Sub,S,pos,len)：用Sub返回S第pos个字符起长度为len的子串
Concat(&T,S1,S2)：串连接，用T返回连接好的新串
Index(S,T)：在S中查找T第一次出现的位置，否则返回0
ClearString(&S)：将S置为空串
DestroyString(&S)：将串S销毁

## 串的模式匹配算法

1、暴力匹配

O(n*m)

2、KMP算法

O(n+m)

前缀：除了最后一个字符的所有子串。如：abc前缀：a,ab

后缀相似

最长相等前后缀：前缀和后缀的交集

最长相等前后缀长度：最长相等前后缀的长度

部分匹配值（Partial Match，PM）：从第一个字符到每个字符对应的最长相等前后缀。如：abcac对应00010，ababa对应00123

PM右移一位左边第一位补-1后整个数组+1则得到next数组，如abcac对应01112

next[j]含义：在子串的第j个字符与主串发生失配时，则跳转到子串的next[j]位置重新与主串当前位置进行比较

手动求next数组？
next[j]=k的条件：模式串的前k-1个字符组成的字符串与第j个字符之前的k-1个字符组成的字符串相等
即'p~1~p~2~...p~k-1~'='p~j-k+1~p~j-k+2~...p~j-1~'而且不存在k'>k满足该条件

计算机求next数组？
类似动态规划从前往后求
next[1]=0，next[2]=1
设next[j]=k，现在求next[j+1]
情况1：k==1&&p~j~!=p~k~，则next[j+1]=1
情况2：k!=1&&p~j~!=p~k~，则令j=k继续分析next[j]
情况3：p~j~==p~k~，则next[j+1]=k+1

![image-20240217171025390](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240217171025390.png)

代码实现：

```c
void get_next(SString T,int next[]){
	int i=1,j=0;
	next[1]=0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;
			++j;
			next[i]=[j];	//若pi=pj，则next[j+1]=next[j]+1
		}
		else	j=next[j];	//否则令j=next[j]，循环继续
	}
}
```

KMP算法：

```c
int Index_KMP(SString S,SString T,int next[]){
	int i=1,j=1;
	while(i<=S.length&&j<=T.length){
		if(j==0||S.ch[i]==T.ch[j]){
			++i;
			++j;	//继续比较后续字符
		}
		else	j=next[j];	//模式串向右移动
	}
	if(j>T.length)	return i-T.length;	//匹配成功
	else return 0;
}
```

KMP算法优化版（将next数组换为nextval数组，匹配方式不变）

nextval数组求值：

```c
void get_nextval(SString T,int nextval[]){
	int i=1,j=0;
	nextval[1]=0;
	while(i<T.length){
		if(j==0||T.ch[i]==T.ch[j]){
			++i;
			++j;
			if(T.ch[i]!=T.ch[j])	nextval[i]=[j];
			else nextval[i]=nextval[j];
        }
		else	j=nextval[j];
	}
}
```

# 第五章 树与二叉树

## 树的基本概念

1、树的定义：（递归定义）

(1)有且仅有一个根节点

(2)其余节点可分为m个有限集，每个有限集又是一棵树

2、基本术语

祖先：从跟节点到该节点的路径上的任意节点

子孙：该节点延伸出的节点

度：树的度为所有节点度的最大值

有序树和无序树：左右是否有次序

层数：根节点为第一层，以此类推

高度/深度：最大层数

路径长度：路径的边数

树的路径长度：树根到每个结点的路径长的**总和**

3、性质

(1)节点数=所有结点度数之和+1

(2)度为m的树最多有m^i-1^个结点

(3)高度为h的树最多有(m^h^-1)/(m-1)个结点

(4)具有n个结点的m叉数最小高度为log~m~(n*(m-1)+1)向上取整

## 二叉树的概念

1、定义：每个结点最多有两棵子树且有左右之分的树

二叉树!=度为2的有序树（某节点只有一个孩子也有左右之分）

2、特殊二叉树

(1)满二叉树

高度为h，且有2^h^-1个结点

(2)完全二叉树

每个结点都与满二叉树一一对应（只有最后一层比满二叉树少几个节点）

特点：

i<n/2向下取整，则结点i为分支结点，否则为叶节点

叶结点只能在最后两层出现

度为1的结点只能有0或1个（如果是1个一定是左孩子）

某个编号的节点为叶结点则之后的结点都是叶结点

n为奇数则每个分支结点都有左右孩子，n为偶数，则n/2结点只有左孩子

(3)二叉排序树

左孩子<根节点<右孩子

(4)平衡二叉树

任意结点的左子树和右子树的深度差不超过1

3、二叉树性质

(1)n~0~=n~2~+1

(2)第k层最多2^k-1^个结点

(3)具有n个结点的完全二叉树高度为log~2~(n+1)向下取整或log~2~n向下取整+1

4、存储结构

(1)顺序存储

编号为i的结点存在下标为i-1的数组中

0表示不存在的空节点

(2)链式存储

```c
typedef struct BiTNode{
	ElemType data;		//数据域
	struct BiTNode *lchild,*rchild;		//左、右孩子指针
}
```

含有n个结点的二叉链表，有n+1个空指针域

## 二叉树的遍历和线索二叉树

1、二叉树的遍历

N为根结点，L为左结点，R为右结点

(1)先序遍历NLR，PreOrder

```c
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T);		//访问根节点
		PreOrder(T->lchild);		//递归遍历左子树
		PreOrder(T->rchild);		//递归遍历右子树
	}
}
```

(2)中序遍历LNR，inOrder

(3)后序遍历LRN，PostOrder

(4)递归算法转为非递归

以中序为例：

```c
void InOrder2(BiTree T){
	InitStack(S);BiTree p=T;		//初始化空栈S；p是遍历指针
	while(p||!isEmpty(S)){			//栈不空或p不空时循环
		if(p){						//一路向左
			Push(S,p);				//当前结点入栈
			p=p->lchild;			//左孩子不为空，一直向左走
		}
		else{						//出栈，并转向出栈结点的右子树
			Pop(S,p);visit(p);		//栈顶元素出栈，访问出栈结点
			p=p=->rchild;			//向右子树走，p赋值为当前结点的右子树
		}							//返回while循环继续进入if-else语句
	}
}
```

先序：

```c
void PreOrder2(BiTree T){
	InitStack(S);BiTree p=T;		//初始化空栈S；p是遍历指针
	while(p||!isEmpty(S)){			//栈不空或p不空时循环
		if(p){						//一路向左
			visit(p);Push(S,p);		//访问当前结点，并入栈
			p=p->lchild;			//左孩子不为空，一直向左走
		}
		else{						//出栈，并转向出栈结点的右子树
			Pop(S,p);				//栈顶元素出栈
			p=p=->rchild;			//向右子树走，p赋值为当前结点的右子树
		}							//返回while循环继续进入if-else语句
	}
}
```

(5)层次遍历

```c
void LevelOrder(BiTree T){
	InitQueue(Q);					//初始化辅助队列
	BiTree p;
	EnQueue(Q,T);					//将根节点入队
	while(!isEmpty(Q)){				//队列不空则循环
		DeQueue(Q,p);				//队头结点出队
		visit(p);					//访问出队结点
		if(p->lchild!=NULL)
			EnQueue(Q,p->lchild);	//左子树不空，则左子树根节点入队
		if(p->rchild!=NULL)
			EnQueue(Q,p->rchild);	//右子树不空，则右子树根节点入队
	}
}
```

(6)由遍历序列构造二叉树

有中序序列加上其他序列即可唯一确定一颗二叉树

前序+后序不行

2、线索二叉树

(1)定义

```c
typedef struct ThreadNode{
	ElemType data;						//数据元素
	struct ThreadNode *lchild,*rchild;	//左右孩子指针
	int ltag,rtag;						//左右线索标志
}ThreadNode,*ThreadTree;
```

ltag或rtag=0表示对应指针指向孩子结点

ltag=1表示lchild指针指向结点的前驱

rtag=1表示rchild指针指向结点的后继

(2)中序线索二叉树的构造

遍历一次将二叉树变成中序线索二叉树

递归算法如下：

```c
void InThread(ThreadTree &p,ThreadTree &pre){
	if(p!=NULL){
		InThread(p->lchild,pre);		//递归，线索化左子树
		if(p->lchild==NULL){			//左子树为空，建立前驱线索
			p->lchild=pre;
			p->ltag=1;
		}
		if(pre!=NULL&&pre->rchild==NULL){
			pre->rchild=p;				//建立前驱结点的后继线索
			pre->rtag=1;
		}
		pre=p;
		InThread(p->rchild,pre);		//递归线索化右子树
	}//if(p!=NULL)
}
```

主过程算法：

```c
void CreateInThread(ThreadTree T){
	ThreadTree pre=NULL;
	if(T!=NULL){					//非空二叉树，线索化
		InThread(T,pre);			//线索化二叉树
		pre->rchild=NULL;			//处理遍历的最后一个结点
		pre->rtag=1;
	}
}
```

(3)中序线索二叉树的遍历

求中序线索二叉树中序序列下的第一个节点

```C
ThreadNode *Firstnode(ThreadNode *p){
	while(p->ltag==0)p=p->lchild;	//最左下节点(不一定是叶结点)
	return p;
}
```

求中序线索二叉树中结点p在中序序列下的后继

```C
ThreadNode *Nextnode(ThreadNode *p){
	if(p->rtag==0)return Firstnode(p->rchild);
	else return p->rchild;			//rtag==1直接返回后继线索
}
```

主算法：

```c
void Inorder(ThreadNode *T){
	for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p))
		visit(p);
}
```

## 树、森林

1、存储结构

(1)双亲表示法

利用数组存储，每个结点和其双亲所在位置（下标）一起存储

根结点下标为0，其伪指针域为-1

其余结点按层次遍历顺序编号

```c
#define MAX_TREE_SIZE 100			//树中最多结点数
typedef struct{						//树的结点定义
	Elemtype data;					//数据元素
	int parent;						//双亲位置域
}PTNode;
typedef struct{						//树的类型定义
	PTNode nodes[MAX_TREE_SIZE];	//双亲表示
	int n;							//结点数
}PTree;
```

(2)孩子表示法

每个结点仍然按顺序存储在数组中

但是每个结点也通过链表连接着其孩子结点

(3)孩子兄弟表示法（二叉树表示法）

firstchild为第一个孩子，nextsibing为兄弟

```c
typedef struct CSNode{
	Elemtype data;				//数据域
	struct CSNode *firstchild,*nextsibling;		//第一个孩子和右兄弟指针
}CSNode,*CSTree;
```

2、树、森林与二叉树的转换

森林与二叉树：先将每棵树转化为二叉树，森林中树与树的关系可以视为兄弟

树与二叉树

树与森林：树根相连

3、遍历

先根遍历

后根遍历

## 树与二叉树的应用

1、哈夫曼树和哈夫曼编码

(1)定义

权w：结点被赋予的数值

带权路径长度l：结点的权值*到该节点的路径长度

树的带权路径长度WPL：所有叶结点的带权路径长度之和

WPL = Σ(l*w)

哈夫曼树：带权路径长度最小的树

(2)构造

每次选取权值最小的两个结点合成

(3)哈夫曼编码

前缀编码：没有一个编码是另一个编码的前缀

哈夫曼编码：
每个结点为需要被编码一个字符
其权值为出现的频率
构造哈夫曼树
左孩子对应一个0编码，右孩子对应一个1编码

![image-20240217170250941](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240217170250941.png)

WPL可视为**最终编码得到的二进制编码的长度**，结点的权值一般*100处理

定长编码得到的二进制长度=100*每个字符需要的定长编码长度

压缩率：(定长编码得到的二进制长度-最终编码得到的二进制编码的长度)/定长编码得到的二进制长度*100%

2、并查集

并查集是一种简单的集合表示，支持三种操作：

Initial(S)：将集合S中的每个元素初始化为一个只有单元素的子集合

Union(S,Root1,Root2)：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不合并

Find(S,x)：查找集合S中单元素x所在的子集合，并返回该子集合的根结点

使用树（森林）的逻辑结构进行存储

实际存储物理结构为数组

下标即为元素

对应值为其父结点（根结点无父结点对应值<0处理）

![image-20240217170141566](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240217170141566.png)

(1)定义

```c
#define SIZE 100
int UFSets[SIZE];			//集合元素数组
```

(2)初始化

```c
void Initial(int S[]){
	for(int i=0;i<SIZE;i++)		//每个自成单元素集合
		S[i]=-1;
}
```

(3)Find操作

```c
int Find(int S[],int x){
	while(S[x]>0)			//循环寻找x的根
		x=S[x];
	return x;
}
```

(4)Union操作

```c
void Union(int S[],int Root1,int Root2){
	if(Root1==Root2)return;		//要求Root1与Root2是不同的集合
	S[Root2]=Root1;				//将根Root2连接到另一根Root1下面
}
```

# 第六章 图

## 图的基本概念

1、图的定义

(1)图G由顶点集V和边集E组成，记为G=(V,E)

(2)有向图：顶点间的边有方向

E={<1,2>,<2,1>}

(3)无向图

E={(1,2),(1,3)}

(4)简单图：不存在重复边，不存在顶点到自身的边，数据结构仅讨论简单图

(5)完全图：把能连的边都连上，无向图有n*(n-1)/2条边

(6)连通图：任意两个顶点之间都有路径存在

(7)强连通图：任意两个顶点之间都有**双向**路径存在

强连通分量：极大强连通子图

(8)生成树：包含图中全部顶点的一个极小连通子图

极小连通子图：既要连通，又要边数最少

(9)简单路径：顶点不重复出现

## 图的存储及基本操作

1、邻接矩阵法

一个一维数组存储图中顶点信息，一个二维数组存储图中边的信息（该二维数组称为邻接矩阵）

![image-20240217175531201](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240217175531201.png)

带权图邻接矩阵可以存储对应权值

```c
#define MaxVertexNum 100			//顶点数目的最大值
typedef char VertexType;			//顶点的数据类型
typedef int EdgeType;				//带权图中边上权值的数据类型
typedef struct{
	VertexType Vex[MaxVertexNum];	//顶点表
	EdgeType Edge[MaxVertexNum][MaxVertexNum];	//邻接矩阵，边表
	int vexnum,arcnum;				//图的当前顶点数和狐数
}MGragh;
```

适用于稠密图

O(|V|^2^)

2、邻接表法

顶点仍然用数组存储，对每个顶点建立一个链表，记录依附于该顶点的边（有向图中是指出该顶点的边（出度））

```C
#define MaxVertexNum 100			//图中顶点数目的最大值
typedef struct ArcNode{				//边表结点
	int adjvex;						//该狐指向的顶点的位置
    struct ArcNode *next;			//指向下一条狐的指针
    //InfoType info;				//网的边权值
}ArcNode;
typedef struct VNode{				//顶点表结点
    VertexType data;				//顶点信息
    ArcNode *first;					//指向第一条依附于该顶点的指针
}VNode,AdjList[MaxVertexNum];
typedef struct{
    AdjList vertices;				//邻接表
    int vexnum,arcnum;				//图的顶点数和狐数
}ALGraph;							//ALGraph是以邻接表存储的图类型
```

适用于稀疏图

有向图O(|V|+|E|)

无向图O(|V|+2*|E|)

3、十字链表

狐结点：tailvex,headvex,hlink,tlink,(info)

tailvex为狐尾结点编号

headvex为狐头结点编号

hlink指向狐头相同的下一个结点

tlink指向狐尾相同的下一个结点

info存放权值或者相关信息

顶点结点：data,firstin,firstout

data存放顶点信息

firstin指向以该顶点为狐头的第一个狐结点

firstout指向以该顶点为狐尾的第一个狐结点

![image-20240217182446181](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240217182446181.png)

4、邻接多重表

狐结点：ivex,ilink,jvex,jlink,(info)

ivex和jvex指向依附的两个顶点编号

ilink指向下一条依附于ivex的边

jlink指向下一条依附于jvex的边

顶点结点：data,firstedge

firstedge指向第一条依附于该顶点的边

## 图的基本操作

Adjacent(G,x,y)：判断图G是否存在边<x,y>或(x,y)

Neighbors(G,x)：列出图G中与结点x邻接的边

InsertVertex(G,x)：在图G中插入顶点x

DeleteVertex(G,x)：从图G中删除顶点x

AddEdge(G,x,y)：若无向边(x,y)或有向边<x,y>不存在，则在G中添加该边

RemoveEdge(G,x,y)：若无向边(x,y)或有向边<x,y>存在，则从G中移除该边

FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号，没有返回-1

NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y外顶点x的下一个顶点的顶点号，若y是x的最后一个邻接点，返回-1

Get_edge_value(G,x,y)：获取边<x,y>或(x,y)的对应权值

Set_edge_value(G,x,y,v)：设置图G中边<x,y>或(x,y)的对应权值为v

## 图的遍历

1、广度优先搜索（Breadth-First-Search,BFS)

(1)基本思想：访问起始顶点v，再访问v的各个邻接结点w1,w2,...,wi，再依次访问w1,w2,...,wi的邻接结点

类似树的层次遍历

```c
bool visited[MAX_VERTEX_NUM];		//访问标记数组
void BFSTraverse(Gragh G){			//对图G进行广度优先遍历
	for(i=0;i<G.vexnum;++i)
		visited[i]=FALSE;			//访问标记数组初始化
	InitQueue(Q);					//初始化辅助队列Q
    for(i=0;ii<G.vexnum;++i)		//从0号顶点开始遍历
        if(!visited[i])				//对每个连通分量调用一次BFS
            BFS(G,i);				//vi从未访问过，从vi开始BFS
}
void BFS(Gragh G,int v){			//从顶点v出发，广度优先遍历图G
    visit(v);						//访问初始顶点v
    visited[v]=TRUE;				//对v作已访问标记
    EnQueue(Q,v);					//顶点v入队列Q
    while(!isEmpty(Q)){
        DeQueue(Q,v);				//顶点v出队列
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
            						//检测v的所有邻接点
            if(!visited[w]){		//w为v的尚未访问的邻接顶点
                visit(w);			//访问顶点w
                visited[w]=TRUE;	//对w作已访问标记
                EnQueue(Q,w);		//顶点w入队
            }//if
    }//while
}
```

(2)性能分析：

空间复杂度：O(|V|)，因为借助了一个辅助队列Q

时间复杂度：

​	邻接表：O(|V|+|E|)

​	邻接矩阵：O(|V|^2^)因为查找每个顶点的邻接点需要O(|V|)

(3)BFS求单源最短路径

使用BFS只能求**非带权图**的单源最短路径(默认每条边权值相同)

```c
void BFS_MIN_Distance(Gragh G,int u){
//d[i]表示从u到i结点的最短路径
    for(i=0;i<G.vexnum;++i)
        d[i]=无穷大;			//初始化路径长度
    visited[u]=TRUE;
    d[u]=0;
    EnQueue(Q,u);
    while(!isEmpty(Q)){			//BFS算法主过程
        DeQueue(Q,u);			//队头元素u出队
        for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
            if(!visited[w]){	//w为u的尚未访问的邻接顶点
                visited[w]=TRUE;//设已访问标记
                d[w]=d[u]+1;	//路径长度+1
                EnQueue(Q,w);	//顶点w入队
            }//if
    }//while
}
```

(4)广度优先生成树

广度优先遍历过程可以得到一棵生成树

一个图的邻接矩阵存储唯一，广度优先生成树唯一

由于一个图的邻接表存储不唯一，广度优先生成树不唯一

2、深度优先搜索（Depth-First-Search，DFS）

(1)基本思想：访问起始顶点v，再访问v邻接且未被访问的结点w1，再访问w1邻接且未被访问的结点w2...

类似树的先序遍历

```c
bool visited[MAX_VERTEX_NUM]; 		//访问标记数组
void DFSTraverse(Gragh G){			//对图G进行深度优先遍历
    for(v=0;v<G.vexnum;++v)
        visited[v]=FALSE;			//初始化已访问标记数组
    for(v=0;v<G.vexnum;++v)			//本代码是从v=0开始遍历
        if(!visited[v])
            DFS(G,v);
}
void DFS(Gragh G,int v){			//从顶点v出发
    visit(v);						//访问顶点v
    visited[v]=TRUE;				//设已访问标记
    for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
        if(!visited[w]){			//w为v的尚未访问的邻接顶点
            DFS(G,w);
        }//if
}
```

(2)性能分析

空间复杂度：O(|V|)，因为递归算法需要一个递归栈

时间复杂度：

​	邻接矩阵：O(|V|^2^)因为查找每个顶点的邻接点需要O(|V|)

​	邻接表：O(|V|+|E|)

(3)深度优先算法生成树

不唯一

3、图的遍历与连通性

对于无向图：如果非连通则需要多次调用DFS或者BFS

对与有向图：如果非强连通也需要多次调用DFS或BFS

## 图的应用

1、最小生成树

包含图G的所有顶点和尽可能少(n-1)的边

最小生成树（Mininum-Spanning-Tree，MST）：树的权（所有边上的权值之和）最小的生成树

最小生成树不唯一，但是权值之和唯一且最小

通用算法：

```c
GENERIC_MST(G){
	T=NULL;
	while T未形成一棵最小生成树;
		do 找到一条最小代价的边(u,v)并且加入T后不会产生回路
			T=T+(u,v);
}
```

(1)Prim算法

step1：选择某一顶点v进入顶点集

step2：选择与该顶点集中某顶点相连的边中权值最小的边

step3：将选择的边相关的顶点也加入顶点集

step4：重复step2和step3直到所有顶点都加入顶点集

```c
void Prim(G,T){
	T=空集;					//初始化空树
	U={w};					//添加任意一个顶点v
	while((V-U)!=空集)		//若树中不含全部顶点
        设(u,v)是使u属于U且v属于(V-U)，且权值最小的边
        T=T+{(u,v)};		//边归入树
    	U=U+{v};			//顶点归入树
}
```

时间复杂度：O(|V|^2^)

适用于边多顶点少

(2)Kruskal算法

step1：选择一条权值最小且不会形成回路的边加入树，其对应顶点也加入树

step2：重复step1直到所有顶点都加入树

```c
void Kruskal(V,T){
    T=V;					//初始化树，仅含顶点
    numS=n;					//连通分量数
    while(numS>1){
        从E中取出权值最小的边(u,v);
        if(u和v属于T中不同的连通分量){
            T=T+{(u,v)};	//将此边加入生成树中
            numS--;			//连通分量数减一
        }
    }
}
```

通常采用堆来存放边的集合，因此每次选择权值最小的边仅需要O(log|E|)的时间

添加新的边可以采用并查集

因此总复杂度：O(|E|log(|E|))

适用于边少顶点多

2、最短路径

(1)单元最短路径

Dijkstra算法

辅助数组：
dist[]：记录从源点v0到其他各顶点的当前最短路径长度，初始为v0到vi的弧长权值（若无狐则为无穷大）
path[]：表示从源点v0到其他顶点的最短路径的前驱结点，用于获得最短路径
顶点集合S

步骤：
step1：初始化顶点集合S为{0}，初始化dist[]，有狐初始化为狐的权值，无狐初始化为无穷大
step2：从余下顶点选择dist[]最小的点vj加入顶点集合S
step3：修改从v0到V-S中任意点k的dist，若dist[j]+arcs[j] [k]<dist[k]，则更新dist[k]为dist[j]+arcs[j] [k]
step4：重复step2,3共n-1次，知道所有点都被选出

总结版步骤：
每轮dist最小的点即为已经确定最短路径长度的点
将该点加入S并更新其他点的dist并从剩下的点中找到dist最小点
直到所有点都被确认为止

时间复杂度：O(|V|^2^)（邻接表与邻接矩阵都是）

注意：存在负数权值时该算法不适用

(2)求每对顶点之间最短路径

Floyd算法

设置方阵A，初始时存储每对顶点之间的路径（类似与邻接矩阵）

遍历每一个顶点，试图将该顶点加入A中的所有路径，如果加入该点后比原长度短则更新

时间复杂度：O(|V|^3^)

3、有向无环图

DAG图

一个有向图中不存在环则称为有向无环图

可以更好的存储二叉树中重复出现的子树

4、拓扑排序

AOV网（用顶点表示活动的网络）：用DAG图表示的工程，顶点表示活动，边表示活动之间的优先序列

拓扑排序：满足以下条件的DAG图
		每个顶点仅出现一次
		若顶点A在B前面则不存在顶点B到A的路径

将AOV网进行拓扑排序的算法：
		step1：从AOV网中选择一个没有前驱的结点
		step2：从网中删除该结点和以他为起点的边
		step3：重复step1,2直到AOV网为空

```c
bool TopologicalSort(Gragh G){
	InitStack(S);				//初始化栈，存储入度为0的顶点
    int i;
    for(i=0;i<G.vexnum;++i)
        if(indegree[i]==0)
            Push(S,i);			//将所有入度为0的结点进栈
    int count=0;				//计数，记录当前已经输出的顶点数
    while(!IsEmpty(S)){			//栈不空，则存在入度为0的顶点
        Pop(S,i);				//栈顶元素出栈
        print[count++]=i;		//输出顶点i
        for(p=G.vertices[i].firstarc;p;p=p->nextarc){
        //将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S
            v=p->adjvex;
            if(!(--indegree[v]))
                Push(S,v);		//入度为0，则入栈
        }
    }//while
    if(count<G.vexnum)
        return false;			//排序失败，有向图中有回路
    else return true;			//拓扑排序成功
}
```

时间复杂度：
		邻接表：O(|V|+|E|)
		邻接矩阵：O(|V|^2^)

5、关键路径

AOE网（用边表示活动的网络）：顶点表示事件，边上的权值表示活动需要的时间

AOE网性质：
		只有某顶点的事件发生后，该顶点出发的边表示的活动才能开始
		只有进入某顶点的所有有向边的活动都结束，该顶点的时间才能发生
		AOE网仅有一个入度为0的点（源点），仅有一个出度为0的点（汇点）
		活动可以并行进行

关键路径：具有最大路径长度的路径

关键活动：关键路径上的活动

(1)事件vk的最早发生时间ve(k)

ve(源点)=0

从前往后计算，ve(k)=Max{ve(j)+Weight(vj,vk)}vj取vk的所有前驱

(2)事件vk的最迟发生时间vl(k)

vl(汇点)=ve(汇点)

从后往前计算，vl(k)=Min{vl(j)-Weight(vk,vj)}vj取vk的所有后继

(3)活动ai的最早开始时间e(i)

若该活动为<vk,vj>，则e(i)=ve(k)

即该活动之前事件的最早开始时间

(4)活动ai的最迟开始时间l(i)

若该活动为<vk,vj>，则l(i)=vl(j)-weight(vk,vj)

即该活动之后事件的最迟开始时间-该活动时间

(5)活动ai的时间余量d(i)=l(i)-e(i)

活动可以拖延的时间

(6)计算关键路径的算法：

step1：按顺序求解各个事件的ve,vl
step2：按顺序求解各个活动的e,l
step3：求解各个活动的d
step4：d==0的活动为关键路径上的活动

(7)

适当缩短关键活动需要的时间可以缩短工期

如果有多条关键路径则需要缩短其公共的关键活动

# 第七章 查找

## 查找的基本概念

查找：在数据集合中寻找满足某种条件的数据元素

查找表（查找结构）：用于查找的数据集合。
		有四种操作：
				查找指定元素是否存在
				查找满足条件的所有元素
				插入
				删除

静态查找表：不需要插入和删除的查找表

平均查找长度：ASL=∑PiCi

Pi为查找第i个元素的概率，一般为1/n

Ci为查找第i个元素需要的比较次数

## 顺序查找和折半查找

1、顺序查找（线性查找）

顺序扫描每个元素

(1)一般线性表的顺序查找

```C
typedef struct{				//查找表的数据结构
	ElemType *elem;			//元素存储空间基址，建表时按实际长度分配，0号单元留空
    int TableLen;			//表的长度
}SSTable;
int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;						//“哨兵”
    for(int i=ST.TableLen;ST.elem[i]!=key;--i);			//从后往前找
    return i;	//若表中不存在关键字为key的元素，将查找到i为0时退出for循环
}
```

将ST.elem[0]称为哨兵

引入目的：不需要检查数组越界

ASL=(n+1)/2

(2)有序表的顺序查找

查找失败可以提前发现并退出，不需要比较到表的另一端

ASL=(n+1)/2

2、折半查找（二分查找）

```c
int Binary_Search(SSTable L,ElemType key){
	int low=0,high=L.TableLen-1,mid;
	while(low<=high){
		mid=(low+high)/2;			//取中间位置
		if(L.elem[mid]==key)
			return mid;				//查找成功则返回所在位置
		else if(L.elem[mid]>key)
			high=mid-1;				//从前半部分继续查找
		else 
			low=mid+1;				//从后半部分继续查找
	}
	return -1;						//查找失败，返回-1
}
```

折半查找的过程可以用一棵二叉树描述，成为判定树，是一棵平衡二叉树

ASL=log(n+1)-1

时间复杂度：O(log(n))

需要线性表可以随机存取，且要有序排列

3、分块查找（索引顺序查找）

基本思想：块内元素无序，块间有序

每一块内最大元素小于下一块内所有元素

索引表中含有：块的最大关键字、块的起始地址

查找过程：先在索引表内顺序查找（或折半），后在块内顺序查找

![image-20240224180229898](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240224180229898.png)

ASL=Li+Ls

Li为索引查找的平均查找长度，Ls为块内查找的平均查找长度

若长度为n的查找表平均分为b块，每块s个记录

则ASL=(s^2^+2s+n)/2s，当s=√n时取得最小值，此时ASL=√n+1

## 树型查找

1、二叉排序树（BST）

(1)定义：左子树<根结点<右子树

中序遍历即为递增有序序列

(2)二叉排序树的查找

```c
BSTNode *BST_Search(BiTree T,ElemType key){
    while(T!=NULL&&key!=T->data){		//若树空或等于根结点值，则结束循环
        if(key<T->data)T=T->lchild;		//小于，则在左子树上查找
        else T=T->rchild;				//大于，则在右子树上查找
    }
    return T;
}
```

(3)二叉排序树的插入

大于插到右子树，小于插到左子树

```c
int BST_Insert(BiTree &T,keyType k){
	if(T==NULL){				//原树为空，新插入的记录为根结点
        T=(BiTree)malloc(sizeof(BSTNode));
    	T->data=k;
    	T->lchild=T->rchild=NULL;
    	return 1;			//返回1，插入成功
    }
	else if(k==T->data)		//树中存在相同关键字的结点，插入失败
        return 0;
    else if(k<T->data)		//插入到T的左子树
        return BST_Insert(T->lchild,k);
    else					//插入到T的右子树
        return BST_Insert(T->rchild,k);
}
```

(4)二叉排序树的构造

按顺序插入即可

```c
void Creat_BST(BiTree &T,KeyType str[],int n){
	T=NULL;					//初始T为空树
    int i=0;
    while(i<n){				//依次将每个关键字插入到二叉排序树中
        BST_Insert(T,str[i]);
        i++;
    }
}
```

(5)二叉排序树的删除

情况1：叶结点，直接删除
情况2：只有左（右）子树，让该结点的子树替代该结点的位置。
情况3：左右子树都存在，在右子树上找到最小的结点（或在左子树上找到最大的点）替换该结点，被替换的结点按删除处理。

![image-20240227114344166](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240227114344166.png)

(6)二叉排序树的查找效率分析

ASL=O(log~2~n)

ASL=每个结点的路径长度之和/结点数

![image-20240227114911037](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240227114911037.png)

2、平衡二叉树（Balanced Binary Tree，或AVL树）

(1)定义

任意结点左右子树高度差绝对值不超过1

(2)插入

先进行二叉排序树的插入，再判断插入后是否导致了不平衡，再根据不同情况进行调整

情况1：LL平衡旋转（右单旋转）

由于在结点A的左孩子(L)的左子树(L)上插入导致不平衡

![image-20240228003330697](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228003330697.png)

情况2：RR平衡旋转（左单旋转）

由于在结点A的右孩子(R)的右子树(R)上插入导致不平衡

![image-20240228003400075](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228003400075.png)

情况3：LR平衡旋转（先左后右双旋转）

由于在结点A的左孩子(L)的右子树(R)上插入导致不平衡

![image-20240228003630491](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228003630491.png)

情况4：RL平衡旋转（先右后左双旋转）

由于在结点A的右孩子(R)的左子树(L)上插入导致不平衡

![image-20240228004026765](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228004026765.png)

(3)删除

先用二叉排序树的方法进行删除

若删除后导致了不平衡，找到第一个不平衡结点z，y为z高度最高的孩子结点，x是y高度最高的孩子结点

平衡调整：
y是z的左孩子，x是y的左孩子(LL，右单旋)
y是z的左孩子，x是y的右孩子(LR，先左后右)
y是z的右孩子，x是y的右孩子(RR，左单旋)
y是z的右孩子，x是y的左孩子(RL，先右后左)

![image-20240228004907640](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228004907640.png)

![image-20240228005231173](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228005231173.png)

(4)平衡二叉树的查找

ASL=O(log~2~n)

3、红黑树

(1)定义

是平衡二叉树的放宽条件版

​	每个结点为红色或黑色
​	根节点是黑色
​	叶结点NULL是黑色
​	不存在两个相邻红色结点
​	对每个结点，从该结点到任意叶结点的路径上，所含黑色结点的数目相同

结论：
	从根节点到叶结点的最长路径不大于最短路径2倍
	有n个内部结点的红黑树高度h<=2*log~2~(n+1)

![image-20240228010241362](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228010241362.png)

![image-20240228010307195](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228010307195.png)

(2)插入

先查找，确定插入位置，插入新结点

如果是根，染成黑色；不是根，染成红色

若插入新结点后不满足红黑树定义（出现父子都是红），则调整

​			黑叔：旋转+染色
​					LL型：右单旋，父换爷+染色
​					RR型：左单旋，父换爷+染色
​					LR型：左右双旋，儿换爷+染色
​					RL型：右左双旋，儿换爷+染色
​			红叔：叔父爷染色+爷结点变新结点

![image-20240228011158689](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228011158689.png)

![image-20240228011229066](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228011229066.png)

![image-20240228011400294](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228011400294.png)

(4)删除

？？？？待填充

## B树和B+树

1、B树及其基本操作

m阶B树是所有结点平衡因子为0的m路平衡查找树

性质：
		每个结点最多有m棵子树（最多含m-1个关键字）
		根节点至少含有两棵子树（至少含有1个关键字）
		除根结点外所有非叶节点至少有m/2向上取整棵子树，即至少含有m/2向上取整-1个关键字

![image-20240228012617378](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228012617378.png)

(1)B树的高度（磁盘存取次数）

![image-20240228013004010](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240228013004010.png)

(2)B树的查找

两个基本操作：
在B树内找结点
在结点内找关键字（顺序/折半）

(3)插入

step1：定位，查到到要插入的关键字key查找失败的非叶结点

step2：插入，插入后关键字个数<m，则可以直接插入；若插入后>m-1，则需要分裂

分裂：从中间位置（m/2向上取整）将该结点拆为两个结点，中间位置结点移到父结点中，如果父结点关键字也超过m-1，则一样的操作

分裂前：

![image-20240301144426704](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301144426704.png)

分裂后：

![image-20240301144511488](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301144511488.png)

(4)删除

若不是最底层的结点（终端结点），则用直接前驱（后继）替代，从而转化为删除其直接前驱（后继）的问题，后者一定是终端结点

![image-20240301150154113](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301150154113.png)

如何删除终端结点？

情况1：直接删除，被删关键字所在结点关键字个数>=m/2向上取整-1

情况2：兄弟够借，被删关键字所在结点关键字个数=m/2向上取整-1，将父结点的关键字取代被删结点，将兄弟结点的关键字取代父结点

![image-20240301150704112](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301150704112.png)

![image-20240301150733732](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301150733732.png)

情况3：兄弟不够借，将父结点和兄弟结点都合并过去（该操作会导致父节点关键字个数减少，可能需要递归操作）

![image-20240301150945117](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301150945117.png)

![image-20240301151034806](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301151034806.png)

2、B+树

条件：
		每个分支结点最多有m棵子树
		根结点至少2棵子树，其他至少m/2向上取整棵子树
		结点关键字个数与子树相等
		相邻叶结点互相连接
		所有分支结点仅包含其各个子结点的最大值及其指针

![image-20240301154805426](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240301154805426.png)

## 散列表

1、基本概念

散列函数：一个把表中关键字映射成关键字对应地址的函数

Hash(key)=addr

冲突：两个不同关键字映射到同一地址

散列表（哈希表）：根据关键字自己进行访问的数据结构

时间复杂度：O(1)

2、散列函数构造方法

(1)直接定址法

H(key)=key	或	H(key)=a*key+b

简单，不会冲突，浪费存储空间

(2)除留余数法

设散列表长度为m

取一个<=m（尽可能接近）的质数p

H(key)=key%p

(3)数字分析法

设关键字是r进制数

取数码分析较均匀的几位作为地址

(4)平方取中法

关键字的平方值的中间几位作为地址

3、处理冲突的方法

(1)开放定址法

可存放新表项的空闲地址，既向他的同义词表项开放又向他的非同义词表项开放

Hi=(H(key)+di)%m

Hi为第i次探测得到的地址

m为散列表长

di为增量序列

线性探测法：
		di=0,1,2,...,m-1
		冲突发生时，顺序查找下一个单元，直到查完全表
		导致大量元素聚集降低查找效率

平方探测法（二次探测法）：
		di=0^2^,1^2^,-1^2^,2^2^,-2^2^,...,k^2^,-k^2^
		k<=m/2，m必须可以表示成4k+3的素数
		可以避免堆积，但是无法查找所有单元

双散列法：
		di=Hash~2~(key)
		第一个散列函数地址冲突时，使用第二个散列函数计算地址增量
		Hi=(H(key)+i*Hash~2~(key))%m

伪随机序列法：
		di=伪随机序列

(2)拉链法（chaining）

相同地址的同义词存储在该地址指向的链表

适用于经常插入，删除的情况

4、散列查找及性能分析

初始化：Addr=Hash(key)

(1)若Addr无记录，返回查找失败；有记录，比较他与key的值，相等返回查找成功，不相等进行(2)
(2)用给定冲突处理方法计算下一个散列地址，Addr置为次地址，转到(1)

查找效率取决于：散列函数，处理冲突方法，装填因子α

α=表中记录数n/散列表长度m

表装得越满，冲突可能性越大

# 第八章 排序

## 排序的基本概念

1、概念：重新排列表中元素，使其按关键字有序

2、稳定性：若表中两个元素R~1~和R~2~，对应关键字相同（key~1~=key~2~）且排序前R~1~在R~2~前面，排序后也必须保持。

如果表中关键字不允许重复，则不考虑稳定性

3、分类

(1)内部排序：完全在内存中排序

(2)外部排序：排序过程中元素不断在内外存移动

4、两种基本操作

比较、移动

5、

对任意n个关键字排序的比较次数至少为log~2~(n!)向上取整

## 插入排序

1、直接插入排序

将每个待排序元素按其关键字大小插入到前面已排序序列中

```c
void InsertSort(ElemType A[],int n){
    int i,j;
    for(i=2;i<=n;i++){			//依次将A[2]-A[n]插入前面已排序序列
        if(A[i]<A[i-1]){			//若A[i]关键码小于其前驱，将A[i]插入有序表
            A[0]=A[i];				//复制为哨兵，A[0]不存放元素
            for(j=i-1;A[0]<A[j];--j)	//从后往前查找待插入位置
                A[j+1]=A[j];		//向后挪位
            A[j+1]=A[0];			//复制到插入位置
        }
    }
}
```

空间复杂度：O(1)

时间复杂度：最好O(n)，最坏O(n^2^)，平均O(n^2^/4)

稳定性：是

2、折半插入排序

查找插入位置时采用折半查找，再统一移动

```c
void InsertSort(ElemType A[],int n){
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){			//依次将A[2]-A[n]插入前面的已排序序列
        A[0]=A[i];				//将A[i]暂存到A[0]
        low=1;high=i-1;			//设置折半查找的范围
        while(low<=high){		//折半查找（默认递增有序）
            mid=(low+high)/2	//取中间点
            if(A[mid]>A[0])high=mid-1;	//查找左半子表
            else low=mid-1;
        }
        for(j=i-1;j>=high+1;--j){
            A[j+1]=A[j];		//统一后移元素，空出插入位置
        A[high+1]=A[0];			//插入操作
        }
    }
}
```

时间复杂度：O(n^2^)

稳定性：是

3、希尔排序（缩小增量排序）

先将待排序的表分为增量相同的子表，对各个子表分别进行插入排序，缩小增量d，直到增量为1为止。

```c
void ShellSort(ElemType A[],int n){
//A[0]只是暂存单元，不是哨兵，当j<=0时，插入位置已到
    int dk,i,j;
    for(dk=n/2;dk>=1;dk=dk/2)		//增量变化（无统一规定）
        for(i=dk+1;i<=n;++i){
            if(A[i]<A[i-dk]){		//需将A[i]插入有序增量子表
                A[0]=A[i];			//暂存在A[0]
                for(j=i-dk;j>0&&A[0]<A[j];j-=dk)
                    A[j+dk]=A[j];	//记录后移，查找插入的位置
                A[j+dk]=A[0];		//插入
            }//if
        }
}
```

时间复杂度：平均O(n^1.3^)，最坏O(n^2^)

稳定性：否

## 交换排序

1、冒泡排序

从后往前（从前往后）两两比较相邻元素的值，若为逆序则交换他们，第一趟结束后，最小的元素交换到第一个位置。

下一趟第一个不参与

```C
void BubbleSort(ElemType A[],int n){
    for(int i=0;i<n-1;i++){
        bool flag=false;			//表示本趟冒泡是否发生过的标志
        for(int j=n-1;j>i;j--){		//一趟冒泡过程
            if(A[j-1]>A[j]){		//若为逆序
                swap(A[j-1],A[j]);	//交换
                flag=true;
            }
        }
        if(flag==false)
            return;					//本趟遍历后没有发生变换，说明表已经有序
    }
}
```

时间复杂度：O(n^2^)

稳定性：是

2、快速排序

在待排序表中任选一个元素pivot，一趟排序把表分为小于pivot和大于pivot两部分

在得到的两个子表重复该过程，直到每部分只有一个元素

```c
void QuickSort(ElemType A[],int low,int high){
    if(low<high){			//递归退出的条件
    //Partition()就是划分操作，将表A[low...high]划分为满足上述条件的两个子表
        int pivotpos=Partition(A,low,high);
        QuickSort(A,low,pivotpos-1);		//依次对两个子表进行递归排序
        QuickSort(A,pivotpos+1,high);
    }
}
```

```c
int Partition(ElemType A[],int low,int high){		//一趟划分
    ElemType pivot=A[low];		//将当前表中第一个元素设为枢纽，对表进行划分
    while(low<high){			//循环跳出条件
        while(low<high&&A[high]>=pivot)	--high;
        A[low]=A[high];			//将比枢纽小的元素移动到左端
        while(low<high&&A[low]<=pivot)	++low;
        A[high]=A[low];			//将比枢纽大的元素移动到右端
    }
    A[low]=pivot;				//枢纽元素存放到最终位置
    return low;
}
```

时间复杂度：O(nlogn)

稳定性：否

## 选择排序

每一趟都选择关键字最小的元素，直到n-1趟做完

1、简单选择排序

```c
void SelectSort(ElemType A[],int n){
    for(int i=0;i<n-1;i++){			//一共进行n-1趟
        int min=i;					//记录最小元素位置
        for(int j=i+1;j<n;j++)		//在A[i...n-1]中选择最小的元素
            if(A[j]<A[min])	min=j;	//更新最小元素位置
        if(min!=i)	swap(A[i],A[min]);		//封装的swap()函数共移动元素3次
    }
}
```

时间复杂度：O(n^2^)

稳定性：否

2、堆排序

大顶堆：L[i]>=L[2i]且L[i]>=L[2i+1]

小顶堆：L[i]<=L[2i]且L[i]<=L[2i+1]

即为完全二叉树，且根节点的值大于（小于）左右结点

如何排序：
(1)构造初始树，从n/2向下取整开始，调整与该结点为根的树，若根节点不是最大的，则与左右结点中较大者交换
(2)输出堆顶元素，将堆尾元素与堆顶交换，重新向下调整

堆建立算法与调整算法：

```c
void BuildMaxHeap(ElemType A[],int len){
    for(int i=len/2;i>0;i--)		//从i=n/2->1，反复调整堆
        HeadAdjust(A,i,len);
}
void HeadAdjust(ElemType A[],int k,int len){
//函数HeadAdjust将元素k为根的子树进行调整
    A[0]=A[k];						//A[0]暂存子树的根节点
    for(int i=2*k;i<len;i*=2){		//沿key较大的子结点向下筛选
        if(i<len&&A[i]<A[i+1])
            i++;					//取key较大的子结点的下标
        if(A[0]>=A[i])	break;		//筛选结束
        else{
            A[k]=A[i];				//将A[i]调整到双亲结点上
            k=i;
        }
    }
    A[k]=A[0];						//被筛选的结点放入最终位置
}
```

堆排序算法：

```c
void HeapSort(ElemType A[],int len){
    BuildMaxHeap(A,len);		//初始建堆
    for(int i=len;i>1;i--){		//n-1趟的交换和建堆过程
        Swap(A[i],A[1]);		//输出堆顶元素
        HeadAdjust(A,l,i-1);	//调整，把剩余的i-1个元素整理成堆
    }
}
```

时间复杂度：O(nlogn)

稳定性：否

## 归并排序和基数排序

1、归并排序

将两个或两个以上有序表合成一个新的有序表，直到只剩下一个有序表

Merge()将两个有序表合成一个新的有序表

```c
ElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));		//辅助数组B
void Merge(ElemType A[],int low,int mid,int high){
//表A的两段A[low...mid]和A[mid+1...high]各自有序，将他们合并成一个有序表
    int i,j,k;
    for(k=low;k<high;k++)
        B[k]=A[k];			//将A中所有的元素复制到B中
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
        if(B[i]<=B[j])		//比较B的左右两段中的元素
            A[k]=B[i++];	//将较小值复制到A中
        else
            A[k]=B[j++];
    }
    while(i<mid)	A[k++]=B[i++];	//若第一个表未检测完，复制
    while(j<=high)	A[k++]=B[j++];	//若第二个表未检测完，复制
}
```

归并排序：调用n/2h向上取整次算法merge()将L中相邻且长度为h的有序段进行两两归并，得到长度为2h的有序段；重复log~2~n向上取整趟

```c
void MergeSort(ElemType A[],int low,int high){
    if(low<high){
        int mid=(low+high)/2;		//从中间划分两个子序列
        MergeSort(A,low,mid);		//对左侧子序列进行递归排序
        MergeSort(A,mid+1,high);	//对右侧子序列进行递归排序
        Merge(A,low,mid,high);		//归并
    }//if
}
```

空间复杂度：O(n)

时间复杂度：O(nlogn)

稳定性：是

2、基数排序

根据关键字各位的大小进行排序

最高位优先法MSD

最低位优先法LSD

![image-20240313144649815](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240313144649815.png)

空间复杂度：需要r个辅助队列O(n)

时间复杂度：需要进行d（位数）趟分配和收集，分配需要O(n)，收集需要O(r)，总共O(d*(n+r))

稳定性：是

## 各种内部排序算法的比较

|   算法种类   |             | 时间复杂度  |             | 空间复杂度 | 稳定性 |
| :----------: | ----------- | ----------- | ----------- | ---------- | ------ |
|              | 最好情况    | 平均情况    | 最坏情况    |            |        |
| 直接插入排序 | O(n)        | O(n^2^)     | O(n^2^)     | O(1)       | 是     |
|   冒泡排序   | O(n)        | O(n^2^)     | O(n^2^)     | O(1)       | 是     |
| 简单选择排序 | O(n^2^)     | O(n^2^)     | O(n^2^)     | O(1)       | 否     |
|   希尔排序   |             |             |             | O(1)       | 否     |
|   快速排序   | O(nlog~2~n) | O(nlog~2~n) | O(n^2^)     | O(log~2~n) | 否     |
|    堆排序    | O(nlog~2~n) | O(nlog~2~n) | O(nlog~2~n) | O(1)       | 否     |
| 2路归并排序  | O(nlog~2~n) | O(nlog~2~n) | O(nlog~2~n) | O(n)       | 是     |
|   基数排序   | O(d(n+r))   | O(d(n+r))   | O(d(n+r))   | O(r)       | 是     |

n小：直接插入，简单选择

基本有序：直接插入，冒泡

n较大：快速排序，堆排序，归并排序

n很大：基数排序

## 外部排序

太抽象了
