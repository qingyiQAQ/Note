# Redis篇

## 缓存穿透

1、定义：查询一个**不存在**的数据，mysql查询不到数据也不会写入缓存，导致一直查询数据库

2、解决方案：

（1）缓存空数据null
优点：简单
缺点：消耗内存，可能发生不一致问题（空数据突然有值了）

（2）布隆过滤器，有请求先在布隆过滤器中检查值是否合法

使用bitmap位图实现
一个id通过多个hash函数取值后写入位图，只有多个hash对应处有值才代表这个id存在

优点：内存占用少，没有多余key
缺点：实现复杂，存在误判

## 缓存击穿

1、定义：某个key过期的时候，刚好来大量请求，瞬间压垮DB

2、解决方案：

（1）**互斥锁**：

优点：结果强一致性
缺点：性能差

（2）**逻辑过期**：不设置过期时间，直接返回过期数据

优点：高可用性、性能好
缺点：不能保证数据绝对一致

## 缓存雪崩

1、定义：同一时段大量key失效或redis宕机，导致DB压力巨大

2、解决方案：

（1）给不同的key设置**随机**值的TTL（过期时间）

（2）利用Redis**集群**提高服务器可用性（哨兵模式、集群模式）

（3）给缓存添加降级**限流**策略（ngxin、spring cloud gateway）
使用与穿透、击穿、雪崩

（4）给业务添加多级缓存（Guava Caffeine）

## 双写一致性

1、定义：数据库数据更新的时候缓存也要更新

2、解决方案：

（1）**延迟双删**：删除缓存->修改数据库-(延时)>删除缓存（延时是需要让数据库主从结点同步）（**不能保证强一致性**）

（2）**分布式锁**：读数据加共享锁（其他线程可读不可写），写数据加排他锁（其他线程不可读写）（可以保证**强一致性**，**性能不高**）

（3）**异步通知**：写入数据后**通过MQ**通知缓存更新

## 数据持久化

1、两种方式：RDB、AOF

2、解决方案：

（1）RDB(Redis Database Backup file)：数据快照，**所有数据**都记录到磁盘中，故障后从磁盘中恢复数据。

```
save		//主进程保存，会阻塞其他命令
bgsave		//开启子进程保存
save 900 1	//900秒内有1个key被修改，则执行bgsave
```

（2）AOF(Append Only File)：Redis处理的**每一个写命令**都会记录在AOF文件中，相当于命令日志。

AOF文件会比RDB大得多

```
appendonly yes		//是否开启AOF功能，默认是no
appendfilename "appendonly.aof"	//AOF文件的名称
appendfsync always	//每执行一次写命令，立即记录到AOF文件
appendfsync everysec//每隔1秒记录到AOF，是默认方案
appendfsync no		//由操作系统决定什么时候写
bgrewriteof			//重写，用最少的命令达到相同效果
auto-aof-rewrite-percentage 100	//AOF文件比上次文件增长多少百分比则触发重写
auto-aof-rewrite-min-size 64mb	//AOF文件体积最小多大以上触发重写
```

|                | RDB                                    | AOF                                           |
| -------------- | -------------------------------------- | --------------------------------------------- |
| 持久化方式     | 定时对整个内存做快照                   | 记录每一次执行的命令                          |
| 数据完整性     | 不完整，两次备份之间会丢失             | 相对完整，取决于刷盘策略                      |
| 文件大小       | 会有压缩，文件体积小                   | 记录命令，文件体积大                          |
| 宕机恢复速度   | 快                                     | 慢                                            |
| 数据恢复优先级 | 低，因为数据完整性不如AOF              | 高，因为数据完整性高                          |
| 系统资源占用   | 高，大量CPU和内存消耗                  | 低，主要是磁盘IO资源，重写时占用大量CPU和内存 |
| 使用场景       | 可以忍受数分钟的数据丢失，追求更快启动 | 对数据安全性要求高                            |

## 数据过期策略

1、定义：数据的**有效时间**过期后，需要删除，可以按照不同策略删除

2、解决方案：

**两种方案混合**

（1）**惰性删除**：数据过期时不删除，**需要该key时**发现过期才删除

对CPU友好，对内存不友好

（2）**定期删除**：**每隔一段时间**，**随机取一定数量**的key进行检查，如果过期则删除

|      | SLOW模式 | FAST模式              |
| ---- | -------- | --------------------- |
| 频率 | 10Hz     | 不固定，间隔不低于2ms |
| 耗时 | <=25ms   | <=1ms                 |

有效减少CPU和内存占用

难以确定操作**时长和频率**

## 数据淘汰策略

1、定义：Redis内存不够时，加新的数据需要删除部分原有的数据，内存淘汰策略

2、解决方案：

（1）noeviction（默认）：不淘汰，内存满**禁止写入**

（2）volatile-ttl：对设置了TTL的key，**TTL越小**越先淘汰

（3）allkeys-random：对全部key，**随机淘汰**

（4）volatile-random：对设置了TTL的key，进行**随机淘汰**

（5）allkeys-lru（推荐）：对全部key，基于LRU算法进行淘汰

（6）volatile-lru：对设置了TTL的key，基于LRU算法淘汰

（7）allkeys-lfu：对全部key，基于lfu算法淘汰

（8）volatile-lfu：对设置了TTL的key，基于LFU算法淘汰

LFU：最少频率使用