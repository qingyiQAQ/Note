# 第一章 计算机系统概述

## 计算机发展历程

1、硬件

第一代——电子管

第二代——晶体管

第三代——中小规模集成电路

第四代——超大规模集成电路

## 计算机系统层次结构

1、组成：硬件系统与软件系统共同组成一个完整的计算机系统

2、计算机硬件

冯诺依曼机基本思想
工作方式：存储程序
硬件系统组成：运算器、存储器、控制器、输入设备、输出设备
指令和数据存储在存储器中，存储形式没有区别
指令和数据均由二进制代码表示，指令由操作码和地址码组成

计算机功能部件：

(1)输入设备

(2)输出设备

(3)存储器
分为主存储器（内存）和辅助存储器（外存）
主存使用按地址的存取方式
地址寄存器MAR存放访问地址
数据寄存器MDR存放读取的数据
MAR、MDR、Cache都在CPU中

(4)运算器
核心是算术逻辑单元ALU
还含有累加器ACC、乘商寄存器MQ、操作寄存器X、变址寄存器IX、基址寄存器BR，前三个为必须
PSW标志寄存器，存放处理机状态信息

(5)控制器
由程序计数器PC、指令寄存器IR、控制单元CU组成
PC来自MAR、IR来自MDR
指令中操作码OP送至CU、地址码Ad(IR)送往MAR取操作数

CPU=运算器+控制器
包含ALU、GPRs（通用寄存器组）、标志寄存器PSW、控制器、指令寄存器IR、程序计数器PC、MAR、MDR

![image-20240315145747156](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240315145747156.png)

CPU与主存之间通过一条总线相连

总线中有：地址、控制、数据3条

3、计算机软件

系统软件：操作系统OS，数据库管理系统DBMS、语言处理程序、分布式软件、网络软件、标准库等

应用软件：...

3个级别语言：机器语言、汇编语言、高级语言

3种翻译程序：汇编程序（汇编->机器）、解释程序（高级->机器，翻译一句执行一句）、编译程序（高级->机器，一次翻译成目标文件）

逻辑功能等价：某功能既可以由硬件实现也可以由软件实现

4、计算机系统的层次结构

微程序机器层->传统机器语言层->操作系统层->汇编语言层->高级语言层->应用程序层

前3层硬件，后3层软件

软硬件交界面：指令集体系结构ISA

5、工作原理

根据PC取指令->指令译码PC+1->取操作数并执行->送结果

hello.c->预处理器cpp->hello.i->编译器ccl->hello.s->汇编器as->hello.o+printf.o可重定位目标程序（二进制）->链接器Id->hello可执行目标程序（二进制）

程序执行过程：

(1)取指令：PC->MAR->M->MDR->IR

(2)分析指令：OP(IR)->CU

(3)执行指令：Ad(IR)->MAR->M->MDR->ACC

## 计算机性能指标

1、主要性能指标

(1)字长：一次整数运算能处理的二进制数据位数，为字节(B)的倍数

(2)数据通路带宽：数据总线一次能传送信息的位数

(3)主存容量：主存储器的最大容量，以字节来衡量，或者字数*字长

(4)运算速度：

吞吐量：单位时间内处理请求的数量，主要取决于主存的存储周期

响应时间：用户向计算机发出一个请求到获得结果的时间，包括CPU运行的时间和等待时间

CPU时间周期（节拍脉冲/T周期）：CPU最小时间单位，执行指令的每个动作需要一个CPU时间周期，主频的倒数

主频（CPU时间频率）：主时钟的频率

CPI（Cycle Per Instruction）：执行一条指令需要的时钟周期数

CPU执行时间=指令条数*CPI/主频

MIPS（Million Instruction Per Second）：每秒百万条指令，MIPS=指令条数/(执行时间*10^6^)=主频/(CPI**10^6^)

MFLOPS：每秒百万次浮点数运算

# 第二章 数据表示和计算

## 数制与编码

1、真值和机器数

真值：“+”、“-”表示正负

机器数：0表示正，1表示负

2、定点数的编码表示

通常用**定点补码整数**表示整数

(1)机器数的定点表示：

定点小数：约定小数点在符号位之后有效数值之前，X=x~0~x~1~x~2~...x~n~，x0为符号位，后面是有效数值

定点整数：约定小数点在有效数值之后符号位之前，X=x~0~x~1~x~2~...x~n~，x0为符号位，后面是有效数值

(2)原码、补码、反码、移码

**原码**：符号由01表示，其他不变，表示范围：-(2^n^-1)<=x<=2^n^-1，零有0,0000和1,0000两种表示

**补码**：

原码->补码：正数不变，负数符号不变，其余位取反+1

补码->原码：符号为为0不变，符号为为1，其余位取反+1

[x]补(小数)=
x,					0<=x<=1
2+x=2-|x|		-1<=x<0

[x]补(整数)=
0,x,				0<=x<2^n^
2^n+1^+x=2^n+1^-|x|	-2^n^<=x<0

表示范围：-2^n^<=x<=2^n^-1

零的表示唯一：0,0000

**反码**：正数不变，负数取反

0的表示不唯一

**移码**：在真值x上加上一个常数2^n^，n为字长减1

为补码的符号位取反

零的表示唯一：1,0000

表示范围：-2^n^<=x<=2^n^-1

3、整数的表示

(1)无符号整数：全部二进制数都是数值位

(2)带符号整数：符号位为第一位，后面是数值位，用补码表示

## 运算方法和运算电路

1、基本运算部件

加法器是ALU的核心部件

(1)一位全加器FA

和表达式：S~i~=A~i~⊕B~i~⊕C~i-1~
进位表达式：C~i~=A~i~B~i~⊕(A~i~⊕B~i~)C~i-1~

(2)串行进位加法器

n个全加器相连得到n位加法器

(3)并行进位加法器

进位产生函数G~i~=A~i~B~i~

进位传递函数Pi=A~i~⊕B~i~

先行进位部件CLA

![image-20240403150930145](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240403150930145.png)

(4)带标志加法器

溢出标志OF=C~n~⊕C~n-1~，表示带符号整数运算时发生溢出，对于无符号数无意义

符号标志SF=F~n-1~（和的最高位），对于无符号数无意义

零标志ZF=1仅当F=0（和为0），对于两者都有意义

进位/借位标志CF=C~out~⊕C~in~，表示无符号数运算的进位/借位，对于带符号数没有意义

(5)算术逻辑单元ALU

输入：n位操作数A、B，进位输入端C~in~，操作控制端ALU~op~

输出：ZF、OF、SF、CF、n位结果F

2、定点数的移位运算

(1)算术移位

移位对象是有符号数，符号位不变

|      |       码制       |     添补代码     |
| :--: | :--------------: | :--------------: |
| 正数 | 原码、反码、补码 |        0         |
|      |       原码       |        0         |
| 负数 |       补码       | 左移添0，右移添1 |
|      |       反码       |        1         |

(2)逻辑移位

操作数为无符号数

左移右移都添0

(3)循环移位

分为带进位标志位CF的循环移位（大循环）和不带进位标志位的循环移位（小循环）

![image-20240403155338593](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240403155338593.png)

3、定点数的加减运算

(1)补码的加减法运算

[A+B]~补~=[A]~补~+[B]~补~(mod 2^n+1^)

[A-B]~补~=[A]~补~+[-B]~补~(mod 2^n+1^)

(2)补码的加减运算电路

设置控制端Sub，Sub为0做加法，Sub为1做减法

Sub为1时Y先取反变成-Y再参与运算

CF=Sub⊕C~out~

(3)溢出判别方法

方法一：采用一位符号位：

设A的符号位为S~A~，B的符号位为S~B~，运算结果的符号位为S~S~

![image-20240406161722159](C:\Users\CC507\AppData\Roaming\Typora\typora-user-images\image-20240406161722159.png)

V=0无溢出，V=1有溢出

方法二：采用双符号位（模4补码）：

设结果的两个符号位为S~S1~和S~S2~

V=S~S1~⊕S~S2~

V=0无溢出，V=1有溢出

方法三：采用一位符号位根据数据位进位情况判断溢出

符号位进位C~S~与最高数位进位C~1~相同则无溢出，否则有溢出

V=C~S~⊕C~1~

V=0无溢出，V=1有溢出

4、定点数的乘除运算

(1)定点数的乘法运算

原码一位乘法：

设[x]~原~=x~s~x~1~x~2~...x~n~，[y]~原~=y~s~y~1~y~2~...y~n~

被乘数与乘数都取绝对值参加运算，视作无符号数，符号位为x~s~⊕y~s~

部分积初值为0，从乘数最低位y~n~开始判断：若y~n~=1，则部分积加上被乘数|x|，右移一位；若y~n~=0，则部分积加上0，右移一位。重复n次。

(2)无符号数乘法运算电路